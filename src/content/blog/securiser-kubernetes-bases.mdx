---
title: "Sécuriser Kubernetes : Les bases souvent négligées"
description: "Les fondamentaux de la sécurité Kubernetes que tout DevOps devrait connaître avant de passer en production."
pubDate: 2025-01-05
tags: ["kubernetes", "security", "devops"]
readingTime: "8 min"
---

La sécurité Kubernetes est souvent perçue comme complexe, mais les fondamentaux sont accessibles et **essentiels** avant toute mise en production. Voici les pratiques que je considère comme non-négociables.

## RBAC : Le contrôle d'accès avant tout

Le Role-Based Access Control (RBAC) est votre première ligne de défense. Par défaut, Kubernetes applique le principe du moindre privilège, mais encore faut-il le configurer correctement.

### Principe de base

Ne donnez **jamais** de permissions `cluster-admin` à une application. Créez des `Roles` et `RoleBindings` spécifiques :

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: pod-reader
  namespace: production
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list"]
```

**Astuce** : Utilisez `kubectl auth can-i` pour tester les permissions avant de les déployer.

## Network Policies : Isoler par défaut

Sans Network Policies, tous vos pods peuvent communiquer entre eux. C'est pratique pour débuter, mais dangereux en production.

### Stratégie deny-all

Commencez toujours par une politique de refus par défaut :

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: production
spec:
  podSelector: {}
  policyTypes:
    - Ingress
    - Egress
```

Puis autorisez explicitement les flux nécessaires. Cette approche inverse la charge mentale : vous devez justifier chaque communication, pas l'interdire.

## Pod Security Standards

Les Pod Security Standards (PSS) ont remplacé les Pod Security Policies. Ils définissent trois niveaux : **Privileged**, **Baseline**, et **Restricted**.

### Configuration au namespace

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
```

Le niveau `restricted` interdit notamment :

- Les conteneurs privileged
- Les montages hostPath
- L'exécution en tant que root

## Image Scanning : Scanner avant de déployer

Intégrez un scanner de vulnérabilités dans votre CI/CD. J'utilise **Trivy** pour sa simplicité :

```bash
trivy image --severity HIGH,CRITICAL mon-image:latest
```

Ne déployez **jamais** une image avec des vulnérabilités critiques. Configurez votre registry pour bloquer automatiquement ces images.

## Secrets Management

Les Secrets Kubernetes ne sont **pas** chiffrés par défaut dans etcd. Trois approches pour sécuriser vos secrets :

### 1. Encryption at rest

Activez le chiffrement dans l'API server :

```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - aescbc:
          keys:
            - name: key1
              secret: <base64-encoded-key>
```

### 2. External Secrets Operator

Utilisez un gestionnaire de secrets externe (Vault, AWS Secrets Manager, etc.) :

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: db-credentials
spec:
  secretStoreRef:
    name: vault
  target:
    name: db-secret
  data:
    - secretKey: password
      remoteRef:
        key: database/prod/password
```

### 3. Sealed Secrets

Pour stocker des secrets chiffrés dans Git :

```bash
kubeseal --format yaml < secret.yaml > sealed-secret.yaml
```

## Conclusion

Ces cinq pratiques constituent le **minimum syndical** pour un cluster Kubernetes en production :

1. **RBAC** configuré au plus juste
2. **Network Policies** deny-all par défaut
3. **Pod Security Standards** en mode restricted
4. **Image scanning** dans la CI/CD
5. **Secrets** chiffrés ou externalisés

La sécurité Kubernetes n'est pas un état mais un processus continu. Commencez par ces bases, puis itérez selon vos besoins spécifiques.

Ces pratiques sont celles que j'applique sur **Kytena**, mon orchestrateur de sécurité Kubernetes. Si vous voulez aller plus loin, je documente mes découvertes sur ce blog.
